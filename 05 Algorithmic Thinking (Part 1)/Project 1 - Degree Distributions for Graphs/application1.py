# Application #1 - Analysis of Citation Graphs

'''
Our task for this application is to analyze the structure of graphs generated 
by citation patterns from scientific papers. Each scientific paper cites many 
other papers, say 20-40, and sometimes (e.g., review papers) hundreds of other 
papers. But, let's face it: It is often the case that the authors of a paper 
are superficially familiar with some (many?) of the papers they cite. So, the 
question is: Are the cited papers chosen randomly (from within the domain of 
the paper) or is there some "hidden pattern"?

Given that we will be looking at "paper i cites paper j" relationships, it 
makes sense to represent the citation data as a directed graph (a citation 
graph) in which the nodes correspond to papers, and there is an edge from node 
i to node j if the paper corresponding to node i cites the paper corresponding 
to node j. Since we're interested in understanding how papers get cited, we 
will analyze the in-degree distribution of a specific graph, and contrast it 
to those of graphs generated by two different random processes.
'''

import project1
import alg_dpa_trial
import matplotlib.pyplot as plt
import random


def loglog_plot_dictionary(graph, xlabel, ylabel, title):
    '''
    Helper function to make a loglog plot from data in a dictionary
    '''
    # format data into x,y lists
    x = []
    y = []
    for key in graph:
        x.append(key)
        y.append(graph[key])
    
    # plot
    plt.loglog(x, y, linestyle = 'None', marker = '.', markersize = '15', 
               markeredgecolor = 'black', markeredgewidth = '1')
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    plt.show()
    
    return
    

def Question_1():
    '''
    Your task for this question is to compute the in-degree distribution for this 
    citation graph. Once you have computed this distribution, you should normalize 
    the distribution (make the values in the dictionary sum to one) and then 
    compute a log/log plot of the points in this normalized distribution.
    '''
    # load data, calculate normalised in-degree distribution
    import alg_load_graph
    citation_graph = alg_load_graph.load_graph(alg_load_graph.CITATION_URL)
    distribution = project1.in_degree_distribution(citation_graph)
    factor = 1.0 / sum(distribution.itervalues())
    normalised_distribution = {key : value * factor for key, value 
                                 in distribution.iteritems()}
    
    # plot
    loglog_plot_dictionary(normalised_distribution, 'Number of Citations', 
                           'Normalized Citation Frequency', 
                           'Log/Log Plot of In-Degree Distribution of Citation Graph\n')
    
    return

    
def er_graph(nodes, probability):
    '''
    Helper function to create graph from ER algorithm for Question 2
    '''
    graph_nodes = range(nodes)
    graph = {}
    for node_i in graph_nodes:
        edges = set()
        for node_j in graph_nodes:
            if node_i != node_j:
                edge_chance = random.random()
                if edge_chance < probability:
                    edges.add(node_j)
        graph[node_i] = edges
    return graph
    
    
def Question_2():
    '''
    For this question, your task is to consider the shape of the in-degree 
    distribution for an ER graph and compare its shape to that of the physics 
    citation graph. In the homework, we considered the probability of a specific 
    in-degree, k, for a single node. Now, we are interested in the in-degree 
    distribution for the entire ER graph. To determine the shape of this 
    distribution, you are welcome to compute several examples of in-degree 
    distributions or determine the shape mathematically.
    
    Once you have determined the shape of the in-degree distributions for ER 
    graphs, compare the shape of this distribution to the shape of the in-degree 
    distribution for the citation graph.
    '''
    # generate ER graph
    graph = er_graph(27770, .0005)
    distribution = project1.in_degree_distribution(graph)
    factor = 1.0 / sum(distribution.itervalues())
    normalised_distribution = {key : value * factor for key, value 
                                 in distribution.iteritems()}

    for node in range(len(graph)):
        if node not in normalised_distribution:
            normalised_distribution[node] = 0

    
    # plot ER graph
    loglog_plot_dictionary(normalised_distribution, 'Degree', 'Probability', 
    'Log/Log Plot of Binomial Distribution')
    
    return
    

def Question_3():
    '''
    For this question, we will choose values for n and m that yield a DPA graph 
    whose number of nodes and edges is roughly the same to those of the citation 
    graph. For the nodes, choosing n to be the number of nodes as the citation 
    graph is easy. Since each step in the DPA algorithm adds m edges to the graph, 
    a good choice for m is an integer that is close to the average out-degree of 
    the physics citation graph.
    
    For this question, provide numerical values for n and m that you will use in 
    your construction of the DPA graph.
    '''
    
    return


def sum_in_degrees(digraph):
    '''
    Helper function for DPA, calculating sum of in-degrees of a graph 
    input is a directed graph represented as a dictionary 
    output is an interger representing the sum of in_degrees
    '''
    sum_in_degrees = 0
    degrees = project1.compute_in_degrees(digraph)
    for node in degrees:
        sum_in_degrees += degrees[node]
    return sum_in_degrees

    
def dpa(n_nodes, m_nodes):
    '''
    Helper function to implement the DPA algorithm for Question 4
    '''
    graph = project1.make_complete_graph(m_nodes)
    dpa_alg = alg_dpa_trial.DPATrial(m_nodes)
    for node in range(m_nodes, n_nodes):
        graph[node] = dpa_alg.run_trial(m_nodes)
    return graph
    
    
def Question_4():
    '''
    Your task for this question is to implement the DPA algorithm, compute a DPA 
    graph using the values from Question 3, and then plot the in-degree 
    distribution for this DPA graph. Creating an efficient implementation of the 
    DPA algorithm from scratch is surprisingly tricky. The key issue in 
    implementing the algorithm is to avoid iterating through every node in the 
    graph when executing Line 6. Using a loop to implement Line 6 leads to 
    implementations that require on the order of 30 minutes in desktop Python to 
    create a DPA graph with 28000 nodes.
    '''
    graph = dpa(28000, 13)
    
    distribution = project1.in_degree_distribution(graph)
    factor = 1.0 / sum(distribution.itervalues())
    normalised_distribution = {key : value * factor for key, value 
                                 in distribution.iteritems()}
    
    loglog_plot_dictionary(normalised_distribution, 'In-Degrees', 
                           'Fraction of Nodes', 
                           'Log/Log Plot of In-Degree Distribution of DPA Graph\n')
    
    return

def Question_5():
    '''
    In this last problem, we will compare the in-degree distribution for the 
    citation graph to the in-degree distribution for the DPA graph as constructed 
    in Question 4. In particular, we will consider whether the shape of these two 
    distributions are similar and, if they are similar, what might be the cause of 
    the similarity.
    '''
    
    return

Question_1()
#Question_2()
#Question_3()
Question_4()
#Question_5()